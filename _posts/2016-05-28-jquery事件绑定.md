---
layout: post
title:  "jQuery的事件绑定"
date:   2016-05-28 17:14:54
categories: jQuery
excerpt:事件绑定
---

* content
{:toc}

## 事件绑定

用户与网页发生交互（比如点击，输入等操作）的特定瞬间就是事件，而要对这些事件作出处理，就需要将事件绑定到DOM元素上，然后通过事件处理器来对事件作出响应。
在原生的js中，事件绑定会因为不同的浏览器出现不同的结果，非常复杂。
但是在jQuery中，提供了很多供开发者进行事件绑定的方法，使用这些办法都不用担心浏览器兼容的问题。

---

### 1、bind() 与 unbind()：
bind()事件绑定方法使用2-3个参数，第一个参数为事件类型，比如click、dbclick等，可以写一个事件类型，也可以写多个事件类型，只要用空格把它们隔开就好了；第二个参数可选参数，为数据；第三个参数为函数，用来处理时间的处理器。在这个函数中，可以通过even.data来使用第二个参数写入的数据。
当我们要通过bind()处理多个事件的时候，还可以使用Map数据类型的对象，以{事件类型：事件处理器}的方式来完成事件绑定。
当用bind()绑定了事件之后，若是想要解除绑定，则可以用对应的unbind()方法，该方法可以解除事件绑定，不传入参数，则会解除对应元素上所有的事件，但若传入了事件类型作为参数，则会解除该事件的绑定，若想解除多个事件的绑定，只要输入要解除事件的名称就好了，它们之间用空格隔开。

---

### 2、one()：
顾名思义，one()绑定的事件，只要发生一次就会解除绑定，而不需要使用其他解除绑定的方法。
one()的用法同bind()相似。

---

### 3、trigger()：
trigger()可以手工触发事件，而且不仅仅限制于浏览器的事件，还可以是改编的事件。

---

### 4、live() 和 die():
live()需要一个表现事件类型的参数和回调函数，这类方法被称为实时方法。能将一个处理器绑定到所以当前或者未来匹配元素的某个事件上。
之所以能对以后动态加入的元素有效，是因为live()使用了“事件委托”，所谓“事件委托”就是指绑定在祖先元素上的事件可以在其后代元素上进行使用。live方法的处理机制就是把事件绑定在DOM树的根节点上，而不是直接绑定在某个元素上。
live()的工作方式与bind()相似，当二者也有很大区别：
（1）若通过live()方法将某个事件绑定到一个元素，响应不仅在当前DOM中的所有元素中可用，而且在未来继承到DOM中的同类元素中也可用。
（2）实时方法不会按照传统的方式冒泡，所以无法调用阻止冒泡的方法来阻止冒泡，但是可以通过在回调函数中返回false来阻止冒泡。
想要解除通过live()方法绑定的事件，可以通过die()方法来从事件系统中删除一个实时事件。

---

### 5、detegate() 和 undetegate():
detegate()可以看作live()的一个替代，用于将一个函数的执行绑定到一个事件上，即使对于以后动态添加的元素也有效。
要想删除实时事件，可以使用undetegate().
但是detegate()又不同于live(),原因在于live()将事件绑定在根节点上，当html结构嵌套很深的时候性能就不高了。而detegate()刚好弥补了这个缺点，它新增了一个参数，可以供开发者传入一个选择器，让开发者将事件绑定到相近的祖先元素上面。


---

### 6、triggerHandler():
该方法与之前的trigger()方法相似，也执行元素在某个事件类型上连接的所有事件处理器。两者区别是：
（1）triggerHandler()不执行浏览器的默认操作，也不会通过冒泡阶段将事件传递给父元素,也不执行任何实时事件。
（2）只有jQuery集合中的第一个元素被出发，这个方法返回的也不是一个jQuery对象，而是一个触发处理器。如果jQuery集合为空，那么会返回undefined












